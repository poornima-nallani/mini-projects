#include <iostream>
#include <vector>
#include <unordered_map>
#include <list>
#include <queue>
#include <stack>
#include <algorithm>

using namespace std;
class Graph {
public:
    void addEdge(const string &src, const string &dest) {
        adjList[src].push_back(dest);
        adjList[dest].push_back(src);
    }
    void displayGraph() {
        for (const auto &pair : adjList) {
            cout << pair.first << ": ";
            for (const auto &neighbor : pair.second) {
                cout << neighbor << " ";
            }
            cout << endl;
        }
    }
    vector<string> findPathBFS(const string &start, const string &end) {
        unordered_map<string, bool> visited;
        unordered_map<string, string> parent;
        queue<string> q;

        q.push(start);
        visited[start] = true;

        while (!q.empty()) {
            string current = q.front();
            q.pop();

            if (current == end) {
                break;
            }

            for (const string &neighbor : adjList[current]) {
                if (!visited[neighbor]) {
                    q.push(neighbor);
                    visited[neighbor] = true;
                    parent[neighbor] = current;
                }
            }
        }
        vector<string> path;
        if (visited[end]) {
            for (string at = end; at != start; at = parent[at]) {
                path.push_back(at);
            }
            path.push_back(start);
            reverse(path.begin(), path.end());
        }
        return path;
    }

private:
    unordered_map<string, list<string>> adjList;
};

int main() {
    Graph graph;

    // Add edges
    graph.addEdge("A", "B");
    graph.addEdge("A", "C");
    graph.addEdge("B", "D");
    graph.addEdge("C", "D");
    graph.addEdge("C", "E");
    graph.addEdge("D", "E");

    cout << "Graph representation:" << endl;
    graph.displayGraph();

    string start, end;
    cout << "\nEnter start node: ";
    cin >> start;
    cout << "Enter end node: ";
    cin >> end;

    vector<string> path = graph.findPathBFS(start, end);

    if (!path.empty()) {
        cout << "Path from " << start << " to " << end << ": ";
        for (const string &node : path) {
            cout << node << " ";
        }
        cout << endl;
    } else {
        cout << "No path found from " << start << " to " << end << endl;
    }

    return 0;
}
